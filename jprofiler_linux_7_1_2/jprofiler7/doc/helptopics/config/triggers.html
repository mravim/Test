<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Offline Profiling and Triggers</title>
<link href="../../../doc/help_common.css" type="text/css" rel="stylesheet">
<link href="../../../doc/help.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
      function detectFrameset() {
        framesetpage="../../../doc/indexRedirect.html";
        thispage=window.location.href;
        if (thispage.indexOf('://')<0) {thispage="://"+thispage;};
        prefix=thispage.substring(0,thispage.lastIndexOf('://'));
        suffix=thispage.substring(thispage.lastIndexOf('://')+3,thispage.length);
        if (parent.location.href==window.location.href) {
          parent.location.href=framesetpage+"?"+prefix+"&&&"+suffix
        } else {
          for(i = 0; i < parent.frames.length; i++) {
            if(parent.frames[i].name == "code" && parent.frames[i].MTMLoaded) {
              parent.frames[i].MTMTrack = true;
              setTimeout("parent.frames[" + i + "].MTMDisplayMenu()", 50);
              break;
            }
          }
        }
      }
    
    </script>
</head>
<body onload="detectFrameset()">
<table width="100%" border="0">
<tr>
<td>
<h2>Offline Profiling and Triggers</h2>
</td><td valign="top" align="right"><a href="../../../doc/helptopics/config/filters.html"><img vspace="0" align="center" border="0" height="16" width="16" src="../../../doc/images/help_previous_16.png"></a>&nbsp;
            <a href="../../../doc/helptopics/config/$folder$.html"><img vspace="0" align="center" border="0" height="16" width="16" src="../../../doc/images/help_up_16.png"></a>&nbsp;
            </td>
</tr>
</table>
<hr>
<br>
<div>

    
<h3>1. Introduction</h3>
    
      There are two fundamentally different ways to profile an application with JProfiler: By default, you profile with
      the JProfiler GUI attached. The JProfiler GUI provides you with buttons to start and stop recording and shows you
      all profiling data. However, there are situations where you would like to profile without the JProfiler GUI
      and analyze the results later on. For this scenario, JProfiler offers offline profiling. Offline
      profiling allows you you start the profiled application with the profiling agent but without the need to connect
      with a JProfiler GUI.
    <br>
    
<p>
      However, offline profiling still requires some actions to be performed. At least one snapshot has to be saved,
      otherwise no profiling data will be available for analysis later on. Also, to see CPU or allocation data,
      you have to start recording at some point. Similarly, if you wish to be able to use the heap walker in the saved
      snapshot, you have to trigger a heap dump at some point.
    </p>
    
<h3>2. Profiling API</h3>
    
<p>
      The first solutions to this problem is the <a href="../../../doc/offline/offline.html">offline profiling API</a>.
      With the offline profiling API, you can programmatically invoke all profiling actions in your code.
    </p>
    
<p>
      The drawback of this approach is that you have to add the JProfiler agent library to the class path
      of your application during development, add temporary profiling code to your source code and
      recompile your code each time you make a change to the programmatic profiling actions.
    </p>
    
<h3>3. Triggers</h3>
    
<p>
      With <a href="../../../doc/sessions/triggers/triggerSettings.html">triggers</a>, you can specify all profiling actions
      in the JProfiler GUI without modifying your source code. Triggers are saved in the JProfiler config file.
      The config file and the session id are passed to the profiling agent
      on the command line when you start with offline profiling enabled, so the profiling agent can read those trigger
      definitions.
    </p>
    
<p>
      
<img style="vertical-align: middle" align="middle" border="0" src="../../../doc/images/trigger_settings.png">
    </p>
    
<p>
      In contrast to the profiling API use case where you add calls to your source code, triggers are activated
      when a certain event occurs in the JVM. For example, if you would have added a call to a certain profiling action
      at the beginning or at the end of a method when using the profiling API, you can use a method invocation trigger
      instead. Instead of creating your own timer thread to periodically save a snapshot, you can use a timer trigger.
    </p>
    
<p>
      Each trigger has a list of actions that are performed when the associated event occurs. Some of these actions
      correspond to profiling actions in the offline profiling API. In addition there are other actions
      that go beyond the controller functions such as the actions to print method calls with parameters and return values
      or the action to invoke an interceptor for a method.
    </p>
  
</div>
<br>
<hr>
<table width="100%" border="0">
<tr>
<td></td><td valign="top" align="right"><a href="../../../doc/helptopics/config/filters.html"><img vspace="0" align="center" border="0" height="16" width="16" src="../../../doc/images/help_previous_16.png"></a>&nbsp;
            <a href="../../../doc/helptopics/config/$folder$.html"><img vspace="0" align="center" border="0" height="16" width="16" src="../../../doc/images/help_up_16.png"></a>&nbsp;
            </td>
</tr>
</table>
</body>
</html>
